/* 
 * Engage Digital API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp.Portable;
using RingCentral.EngageDigital.Client;
using RingCentral.EngageDigital.Model;

namespace RingCentral.EngageDigital.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        internal interface IThreadsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Archiving a thread
        /// </summary>
        /// <remarks>
        /// Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        Thread ArchiveThread (string threadId);

        /// <summary>
        /// Archiving a thread
        /// </summary>
        /// <remarks>
        /// Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        ApiResponse<Thread> ArchiveThreadWithHttpInfo (string threadId);
        /// <summary>
        /// Categorizing a thread
        /// </summary>
        /// <remarks>
        /// This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>Thread</returns>
        Thread CategorizeThread (string threadId, List<string> threadCategoryIds = null);

        /// <summary>
        /// Categorizing a thread
        /// </summary>
        /// <remarks>
        /// This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>ApiResponse of Thread</returns>
        ApiResponse<Thread> CategorizeThreadWithHttpInfo (string threadId, List<string> threadCategoryIds = null);
        /// <summary>
        /// Close a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        Thread CloseThread (string threadId);

        /// <summary>
        /// Close a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        ApiResponse<Thread> CloseThreadWithHttpInfo (string threadId);
        /// <summary>
        /// Getting all threads
        /// </summary>
        /// <remarks>
        /// This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>GetAllThreadsResponse</returns>
        GetAllThreadsResponse GetAllThreads (int? q = null, int? offset = null, int? limit = null);

        /// <summary>
        /// Getting all threads
        /// </summary>
        /// <remarks>
        /// This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>ApiResponse of GetAllThreadsResponse</returns>
        ApiResponse<GetAllThreadsResponse> GetAllThreadsWithHttpInfo (int? q = null, int? offset = null, int? limit = null);
        /// <summary>
        /// Getting a thread from its id
        /// </summary>
        /// <remarks>
        /// This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        Thread GetThread (string threadId);

        /// <summary>
        /// Getting a thread from its id
        /// </summary>
        /// <remarks>
        /// This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        ApiResponse<Thread> GetThreadWithHttpInfo (string threadId);
        /// <summary>
        /// Open a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        Thread OpenThread (string threadId);

        /// <summary>
        /// Open a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        ApiResponse<Thread> OpenThreadWithHttpInfo (string threadId);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Archiving a thread
        /// </summary>
        /// <remarks>
        /// Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        System.Threading.Tasks.Task<Thread> ArchiveThreadAsync (string threadId);

        /// <summary>
        /// Archiving a thread
        /// </summary>
        /// <remarks>
        /// Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        System.Threading.Tasks.Task<ApiResponse<Thread>> ArchiveThreadAsyncWithHttpInfo (string threadId);
        /// <summary>
        /// Categorizing a thread
        /// </summary>
        /// <remarks>
        /// This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>Task of Thread</returns>
        System.Threading.Tasks.Task<Thread> CategorizeThreadAsync (string threadId, List<string> threadCategoryIds = null);

        /// <summary>
        /// Categorizing a thread
        /// </summary>
        /// <remarks>
        /// This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        System.Threading.Tasks.Task<ApiResponse<Thread>> CategorizeThreadAsyncWithHttpInfo (string threadId, List<string> threadCategoryIds = null);
        /// <summary>
        /// Close a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        System.Threading.Tasks.Task<Thread> CloseThreadAsync (string threadId);

        /// <summary>
        /// Close a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        System.Threading.Tasks.Task<ApiResponse<Thread>> CloseThreadAsyncWithHttpInfo (string threadId);
        /// <summary>
        /// Getting all threads
        /// </summary>
        /// <remarks>
        /// This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>Task of GetAllThreadsResponse</returns>
        System.Threading.Tasks.Task<GetAllThreadsResponse> GetAllThreadsAsync (int? q = null, int? offset = null, int? limit = null);

        /// <summary>
        /// Getting all threads
        /// </summary>
        /// <remarks>
        /// This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>Task of ApiResponse (GetAllThreadsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetAllThreadsResponse>> GetAllThreadsAsyncWithHttpInfo (int? q = null, int? offset = null, int? limit = null);
        /// <summary>
        /// Getting a thread from its id
        /// </summary>
        /// <remarks>
        /// This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        System.Threading.Tasks.Task<Thread> GetThreadAsync (string threadId);

        /// <summary>
        /// Getting a thread from its id
        /// </summary>
        /// <remarks>
        /// This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        System.Threading.Tasks.Task<ApiResponse<Thread>> GetThreadAsyncWithHttpInfo (string threadId);
        /// <summary>
        /// Open a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        System.Threading.Tasks.Task<Thread> OpenThreadAsync (string threadId);

        /// <summary>
        /// Open a thread
        /// </summary>
        /// <remarks>
        /// Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </remarks>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        System.Threading.Tasks.Task<ApiResponse<Thread>> OpenThreadAsyncWithHttpInfo (string threadId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class ThreadsApi : IThreadsApi
    {
        private RingCentral.EngageDigital.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ThreadsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ThreadsApi(String basePath)
        {
            this.Configuration = new RingCentral.EngageDigital.Client.Configuration { BasePath = basePath };

            ExceptionFactory = RingCentral.EngageDigital.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ThreadsApi"/> class
        /// </summary>
        /// <returns></returns>
        public ThreadsApi()
        {
            this.Configuration = RingCentral.EngageDigital.Client.Configuration.Default;

            ExceptionFactory = RingCentral.EngageDigital.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ThreadsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ThreadsApi(RingCentral.EngageDigital.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = RingCentral.EngageDigital.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = RingCentral.EngageDigital.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public RingCentral.EngageDigital.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public RingCentral.EngageDigital.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Archiving a thread Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        public Thread ArchiveThread (string threadId)
        {
             ApiResponse<Thread> localVarResponse = ArchiveThreadWithHttpInfo(threadId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Archiving a thread Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        public ApiResponse< Thread > ArchiveThreadWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->ArchiveThread");

            var localVarPath = "./content_threads/{threadId}/ignore";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ArchiveThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Archiving a thread Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        public async System.Threading.Tasks.Task<Thread> ArchiveThreadAsync (string threadId)
        {
             ApiResponse<Thread> localVarResponse = await ArchiveThreadAsyncWithHttpInfo(threadId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Archiving a thread Archives the contents of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being archived, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Thread>> ArchiveThreadAsyncWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->ArchiveThread");

            var localVarPath = "./content_threads/{threadId}/ignore";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ArchiveThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Categorizing a thread This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>Thread</returns>
        public Thread CategorizeThread (string threadId, List<string> threadCategoryIds = null)
        {
             ApiResponse<Thread> localVarResponse = CategorizeThreadWithHttpInfo(threadId, threadCategoryIds);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Categorizing a thread This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>ApiResponse of Thread</returns>
        public ApiResponse< Thread > CategorizeThreadWithHttpInfo (string threadId, List<string> threadCategoryIds = null)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->CategorizeThread");

            var localVarPath = "./content_threads/{threadId}/update_categories";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter
            if (threadCategoryIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "thread_category_ids[]", threadCategoryIds)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CategorizeThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Categorizing a thread This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>Task of Thread</returns>
        public async System.Threading.Tasks.Task<Thread> CategorizeThreadAsync (string threadId, List<string> threadCategoryIds = null)
        {
             ApiResponse<Thread> localVarResponse = await CategorizeThreadAsyncWithHttpInfo(threadId, threadCategoryIds);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Categorizing a thread This method updates the categories of a thread. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  If the thread is already being categorized, a 409 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="threadCategoryIds">An array containing the new categories to set on the thread. (optional)</param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Thread>> CategorizeThreadAsyncWithHttpInfo (string threadId, List<string> threadCategoryIds = null)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->CategorizeThread");

            var localVarPath = "./content_threads/{threadId}/update_categories";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter
            if (threadCategoryIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "thread_category_ids[]", threadCategoryIds)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CategorizeThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Close a thread Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        public Thread CloseThread (string threadId)
        {
             ApiResponse<Thread> localVarResponse = CloseThreadWithHttpInfo(threadId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Close a thread Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        public ApiResponse< Thread > CloseThreadWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->CloseThread");

            var localVarPath = "./content_threads/{threadId}/close";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CloseThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Close a thread Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        public async System.Threading.Tasks.Task<Thread> CloseThreadAsync (string threadId)
        {
             ApiResponse<Thread> localVarResponse = await CloseThreadAsyncWithHttpInfo(threadId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Close a thread Thread closure/opening is only available for the following sources: * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to close a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object do not is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be closed or if the user does not have the permission to close a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Thread>> CloseThreadAsyncWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->CloseThread");

            var localVarPath = "./content_threads/{threadId}/close";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CloseThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Getting all threads This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>GetAllThreadsResponse</returns>
        public GetAllThreadsResponse GetAllThreads (int? q = null, int? offset = null, int? limit = null)
        {
             ApiResponse<GetAllThreadsResponse> localVarResponse = GetAllThreadsWithHttpInfo(q, offset, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Getting all threads This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>ApiResponse of GetAllThreadsResponse</returns>
        public ApiResponse< GetAllThreadsResponse > GetAllThreadsWithHttpInfo (int? q = null, int? offset = null, int? limit = null)
        {

            var localVarPath = "./content_threads";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (q != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAllThreads", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetAllThreadsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (GetAllThreadsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetAllThreadsResponse)));
        }

        /// <summary>
        /// Getting all threads This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>Task of GetAllThreadsResponse</returns>
        public async System.Threading.Tasks.Task<GetAllThreadsResponse> GetAllThreadsAsync (int? q = null, int? offset = null, int? limit = null)
        {
             ApiResponse<GetAllThreadsResponse> localVarResponse = await GetAllThreadsAsyncWithHttpInfo(q, offset, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Getting all threads This method renders threads ordered by last content date (descending). Only threads in sources where token’s user has “read” permission are returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">A search query to filter threads. Please refer to ​Search &amp; filtering parameters​ for more details. (optional)</param>
        /// <param name="offset">The record index to start. Default value is 0. (optional)</param>
        /// <param name="limit">The max number of records to return. Default value is 30, max value is 150. (optional)</param>
        /// <returns>Task of ApiResponse (GetAllThreadsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GetAllThreadsResponse>> GetAllThreadsAsyncWithHttpInfo (int? q = null, int? offset = null, int? limit = null)
        {

            var localVarPath = "./content_threads";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (q != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAllThreads", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetAllThreadsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (GetAllThreadsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetAllThreadsResponse)));
        }

        /// <summary>
        /// Getting a thread from its id This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        public Thread GetThread (string threadId)
        {
             ApiResponse<Thread> localVarResponse = GetThreadWithHttpInfo(threadId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Getting a thread from its id This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        public ApiResponse< Thread > GetThreadWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->GetThread");

            var localVarPath = "./content_threads/{threadId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Getting a thread from its id This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        public async System.Threading.Tasks.Task<Thread> GetThreadAsync (string threadId)
        {
             ApiResponse<Thread> localVarResponse = await GetThreadAsyncWithHttpInfo(threadId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Getting a thread from its id This method renders a thread from given id. If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Thread>> GetThreadAsyncWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->GetThread");

            var localVarPath = "./content_threads/{threadId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Open a thread Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Thread</returns>
        public Thread OpenThread (string threadId)
        {
             ApiResponse<Thread> localVarResponse = OpenThreadWithHttpInfo(threadId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Open a thread Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>ApiResponse of Thread</returns>
        public ApiResponse< Thread > OpenThreadWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->OpenThread");

            var localVarPath = "./content_threads/{threadId}/open";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("OpenThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

        /// <summary>
        /// Open a thread Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of Thread</returns>
        public async System.Threading.Tasks.Task<Thread> OpenThreadAsync (string threadId)
        {
             ApiResponse<Thread> localVarResponse = await OpenThreadAsyncWithHttpInfo(threadId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Open a thread Thread closure/opening is only available for the following sources:  * Emails * Answers * Ideas * Facebook Messenger * Google+ * Lithium * Mobile Messaging  Starts a job to open a thread. It returns the thread but as the job is asynchronous, the state of the “close” attribute in the returned object is the one when the job started.  If token’s user does not have “read” on thread’s source a 404 HTTP response will be returned. Returns a 403 if the thread cannot be opened or if the user does not have the permission to open a thread.  Authorization​: no.
        /// </summary>
        /// <exception cref="RingCentral.EngageDigital.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <returns>Task of ApiResponse (Thread)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Thread>> OpenThreadAsyncWithHttpInfo (string threadId)
        {
            // verify the required parameter 'threadId' is set
            if (threadId == null)
                throw new ApiException(400, "Missing required parameter 'threadId' when calling ThreadsApi->OpenThread");

            var localVarPath = "./content_threads/{threadId}/open";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (threadId != null) localVarPathParams.Add("threadId", this.Configuration.ApiClient.ParameterToString(threadId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("OpenThread", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Thread>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Thread) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Thread)));
        }

    }
}
